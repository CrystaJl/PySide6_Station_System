////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функция получат мгновенные значения счетчика. Полученные данные сохраняются в память LW Weintek.
//
// GetMercury(netAdr, adres)
// netAdr - Адрес счетчика
// adres -- Начальная позиция памяти LW Weintek
//
// Карта памяти:
// Адрем           Коментарий                                       Тип данных                  Множитель
// adres           Серийный номер                                   (32bit unsigned int)        1
// adres + 2       Частота                                          (32bit unsigned int)        0.01
// adres + 4       Ток фазы U1                                      (32bit unsigned int)        0.01
// adres + 6       Ток фазы U2                                      (32bit unsigned int)        0.01
// adres + 8       Ток фазы U3                                      (32bit unsigned int)        0.01
// adres + 10      напряжение фазы U1                               (32bit unsigned int)        0.01
// adres + 12      напряжение фазы U2                               (32bit unsigned int)        0.01
// adres + 14      напряжение фазы U3                               (32bit unsigned int)        0.01
// adres + 16      Активная мощность по всем фазам                  (32bit int)                 0.01
// adres + 18      Активная мощность фаза U1                        (32bit int)                 0.01
// adres + 20      Активная мощность фаза U2                        (32bit int)                 0.01
// adres + 22      Активная мощность фаза U3                        (32bit int)                 0.01
// adres + 24      Реактивная мощность по всем фазам                (32bit int)                 0.01
// adres + 26      Реактивная мощность фаза U1                      (32bit int)                 0.01
// adres + 28      Реактивная мощность фаза U2                      (32bit int)                 0.01
// adres + 30      Реактивная мощность фаза U3                      (32bit int)                 0.01
// adres + 32      Общая мощность по всем фазам                     (32bit int)                 0.01
// adres + 34      Общая мощность фаза U1                           (32bit int)                 0.01
// adres + 36      Общая мощность фаза U2                           (32bit int)                 0.01
// adres + 38      Общая мощность фаза U3                           (32bit int)                 0.01
// adres + 40      cos фи по всем фазам                             (32bit int)                 0.01
// adres + 42      cos фи фаза U1                                   (32bit int)                 0.01
// adres + 44      cos фи фаза U2                                   (32bit int)                 0.01
// adres + 46      cos фи фаза U3                                   (32bit int)                 0.01
// adres + 48      Угол между фазами U1 и U2                        (32bit int)                 0.01
// adres + 50      Угол между фазами U1 и U3                        (32bit int)                 0.01
// adres + 52      Угол между фазами U2 и U3                        (32bit int)                 0.01
// adres + 54      Счетчик ошибок связи (при 10 обнуление)          (16bit)                     1
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
sub unsigned short GetMercury(short netAdr, short adres)
    //**************************************************************************************************************************
    // Проверка входных данных
    //**************************************************************************************************************************
    if netAdr == 0 and netAdr > 256 then
        return 255
    else if adres > 9002 - 54 and adres < 11495 and adres > 12300 - 54 then
        return 255
    end if

    char response[19]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
    short length=0, i=0, CRC16=0
    int temp=0, dir=0
    Char TempChar[10]={0,0,0,0,0,0,0,0,0,0}
    //**************************************************************************************************************************
    // Команды
    //**************************************************************************************************************************
    Char Access[11]     = { 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}    // Запрос на доступ к данным
    Char Sn[5]          = { 0x00, 0x08, 0x00 }                                       // серийный номер
    Char Freq[6]        = { 0x00, 0x08, 0x16, 0x40 }                                 // частота
    Char Current[6]     = { 0x00, 0x08, 0x16, 0x21 }                                 // ток
    Char Suply[6]       = { 0x00, 0x08, 0x16, 0x11 }                                 // напряжение
    Char Power[6]       = { 0x00, 0x08, 0x16, 0x00 }                                 // мощность p
    Char PowerQ[6]      = { 0x00, 0x08, 0x16, 0x08 }                                 // мощность Q
    Char PowerS[6]      = { 0x00, 0x08, 0x16, 0x04 }                                 // мощность S
    Char CosF[6]        = { 0x00, 0x08, 0x16, 0x30 }                                 // cosf
    Char Angle[6]       = { 0x00, 0x08, 0x16, 0x51 }                                 // углы
    //**************************************************************************************************************************
    // Устанавливаю адрес счетчика устройства, во все команды и расчитываю CRC
    //**************************************************************************************************************************
    Sn[0]                           = netAdr
    CRC(Sn[0], CRC16, 3)
    Sn[3]                           = CRC16&0xFF
    Sn[4]                           = (CRC16>>8)&0xFF
    Access[0]                       = netAdr
    CRC(Access[0], CRC16, 9)
    Access[9]                       = CRC16&0xFF
    Access[10]                      = (CRC16>>8)&0xFF
    Freq[0]                         = netAdr
    CRC(Freq[0], CRC16, 4)
    Freq[4]                         = CRC16&0xFF
    Freq[5]                         = (CRC16>>8)&0xFF
    Current[0]                      = netAdr
    CRC(Current[0], CRC16, 4)
    Current[4]                      = CRC16&0xFF
    Current[5]                      = (CRC16>>8)&0xFF
    Suply[0]                        = netAdr
    CRC(Suply[0], CRC16, 4)
    Suply[4]                        = CRC16&0xFF
    Suply[5]                        = (CRC16>>8)&0xFF
    Power[0]                        = netAdr
    CRC(Power[0], CRC16, 4)
    Power[4]                        = CRC16&0xFF
    Power[5]                        = (CRC16>>8)&0xFF
    PowerQ[0]                       = netAdr
    CRC(PowerQ[0], CRC16, 4)
    PowerQ[4]                       = CRC16&0xFF
    PowerQ[5]                       = (CRC16>>8)&0xFF
    PowerS[0]                       = netAdr
    CRC(PowerS[0], CRC16, 4)
    PowerS[4]                       = CRC16&0xFF
    PowerS[5]                       = (CRC16>>8)&0xFF
    CosF[0]                         = netAdr
    CRC(CosF[0], CRC16, 4)
    CosF[4]                         = CRC16&0xFF
    CosF[5]                         = (CRC16>>8)&0xFF
    Angle[0]                        = netAdr
    CRC(Angle[0], CRC16, 4)
    Angle[4]                        = CRC16&0xFF
    Angle[5]                        = (CRC16>>8)&0xFF

    //**************************************************************************************************************************
    // Получение доступа
    //**************************************************************************************************************************
    OUTPORT(Access[0], "Free Protocol", 11)
    FILL(response[0], 0, 16)
    INPORT(Response[0], "Free Protocol", 4, length)
    CRC(Response[0], CRC16, 2)
    if length == 4 and Response[0]&~0Xffffff00 == netAdr and Response[1]&~0Xffffff00 == 0 and (Response[2]&~0Xffffff00)==(CRC16&0xFF) and (Response[3]&~0Xffffff00)==((CRC16>>8)&0xFF) then
        temp = 0
        SetData(temp, "Local HMI", LW, adres+54, 1) // Сброс счетчика ошибок соеденения
    //**************************************************************************************************************************
    // Запрос серийного номера
    //**************************************************************************************************************************
        OUTPORT(Sn[0], "Free Protocol", 5)
        FILL(response[0], 0, 16)
        INPORT(Response[0], "Free Protocol", 10, length)
        CRC(Response[0], CRC16, 8)
        if length == 10 and Response[0]&~0Xffffff00 == netAdr then
            if (Response[8]&~0Xffffff00)==(CRC16&0xFF) and (Response[9]&~0Xffffff00)==((CRC16>>8)&0xFF) then
                if (response[1]&~0Xffffff00) < 10 then
                    TempChar[0] = '0'
                    DEC2ASCII(response[1]&~0Xffffff00, TempChar[1], 1)
                else
                    DEC2ASCII(response[1]&~0Xffffff00, TempChar[0], 2)
                end if
                if (response[2]&~0Xffffff00) < 10 then
                    TempChar[2] = '0'
                    DEC2ASCII(response[2]&~0Xffffff00, TempChar[3], 1)
                else
                    DEC2ASCII(response[2]&~0Xffffff00, TempChar[2], 2)
                end if
                if (response[3]&~0Xffffff00) < 10 then
                    TempChar[4] = '0'
                    DEC2ASCII(response[3]&~0Xffffff00, TempChar[5], 1)
                else
                    DEC2ASCII(response[3]&~0Xffffff00, TempChar[4], 2)
                end if
                if (response[4]&~0Xffffff00) < 10 then
                    TempChar[6] = '0'
                    DEC2ASCII(response[4]&~0Xffffff00, TempChar[7], 1)
                else
                    DEC2ASCII(response[4]&~0Xffffff00, TempChar[6], 2)
                end if
                ASCII2DEC(TempChar[0], temp, 8)
                SetData(temp, "Local HMI", LW, adres, 1)
            end if
        end if
    //**************************************************************************************************************************
    // Запрос частоты
    //**************************************************************************************************************************
        OUTPORT(Freq[0], "Free Protocol", 6)
        FILL(response[0], 0, 16)
        INPORT(Response[0], "Free Protocol", 6, length)
        CRC(Response[0], CRC16, 4)
        if length == 6 and Response[0]&~0Xffffff00 == netAdr then
            if (Response[4]&~0Xffffff00)==(CRC16&0xFF) and (Response[5]&~0Xffffff00)==((CRC16>>8)&0xFF) then
                temp = ((response[1]<<16)&~0XFF00FFFF)|((response[3]<<8)&~0XFFFF00FF)|(response[2]&~0Xffffff00)
                SetData(temp, "Local HMI", LW, adres+2, 1)
            end if
        end if
    //**************************************************************************************************************************
    // Запрос токов
    //**************************************************************************************************************************
        OUTPORT(Current[0], "Free Protocol", 6)
        FILL(response[0], 0, 16)
        INPORT(Response[0], "Free Protocol", 12, length)
        CRC(Response[0], CRC16, 10)
        if length == 12 and Response[0]&~0Xffffff00 == netAdr then
            if (Response[10]&~0Xffffff00)==(CRC16&0xFF) and (Response[11]&~0Xffffff00)==((CRC16>>8)&0xFF) then
                temp = ((response[1]<<16)&~0XFF00FFFF)|((response[3]<<8)&~0XFFFF00FF)|(response[2]&~0Xffffff00) // ток U1
                SetData(temp, "Local HMI", LW, adres+4, 1)
                temp = ((response[4]<<16)&~0XFF00FFFF)|((response[6]<<8)&~0XFFFF00FF)|(response[5]&~0Xffffff00) // ток U2
                SetData(temp, "Local HMI", LW, adres+6, 1)
                temp = ((response[7]<<16)&~0XFF00FFFF)|((response[9]<<8)&~0XFFFF00FF)|(response[8]&~0Xffffff00) // ток U3
                SetData(temp, "Local HMI", LW, adres+8, 1)
            end if
        end if
    //**************************************************************************************************************************
    // Запрос напряжения
    //**************************************************************************************************************************
        OUTPORT(Suply[0], "Free Protocol", 6)
        FILL(response[0], 0, 16)
        INPORT(Response[0], "Free Protocol", 12, length)
        CRC(Response[0], CRC16, 10)
        if length == 12 and Response[0]&~0Xffffff00 == netAdr then
            if (Response[10]&~0Xffffff00)==(CRC16&0xFF) and (Response[11]&~0Xffffff00)==((CRC16>>8)&0xFF) then
                temp = ((response[1]<<16)&~0XFF00FFFF)|((response[3]<<8)&~0XFFFF00FF)|(response[2]&~0Xffffff00) // Напряжение U1
                SetData(temp, "Local HMI", LW, adres+10, 1)
                temp = ((response[4]<<16)&~0XFF00FFFF)|((response[6]<<8)&~0XFFFF00FF)|(response[5]&~0Xffffff00) // Напряжение U2
                SetData(temp, "Local HMI", LW, adres+12, 1)
                temp = ((response[7]<<16)&~0XFF00FFFF)|((response[9]<<8)&~0XFFFF00FF)|(response[8]&~0Xffffff00) // Напряжение U3
                SetData(temp, "Local HMI", LW, adres+14, 1)
            end if
        end if
    //**************************************************************************************************************************
    // Запрос мощности P (Активная)
    //**************************************************************************************************************************
        OUTPORT(Power[0], "Free Protocol", 6)
        FILL(response[0], 0, 16)
        INPORT(Response[0], "Free Protocol", 15, length)
        CRC(Response[0], CRC16, 13)
        if length == 15 and Response[0]&~0Xffffff00 == netAdr then
            if (Response[13]&~0Xffffff00)==(CRC16&0xFF) and (Response[14]&~0Xffffff00)==((CRC16>>8)&0xFF) then
                // Мощность по всем фазам
                if (response[1]&~0Xffffff00) == 0x40  or (response[1]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[1]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[3]<<8)&~0XFFFF00FF)|(response[2]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+16, 1)
                // Мощность на фазе U1
                if (response[4]&~0Xffffff00) == 0x40  or (response[4]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[4]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[6]<<8)&~0XFFFF00FF)|(response[5]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+18, 1)
                // Мощность на фазе U2
                if (response[7]&~0Xffffff00) == 0x40  or (response[7]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[7]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[9]<<8)&~0XFFFF00FF)|(response[8]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+20, 1)
                // Мощность на фазе U2
                if (response[10]&~0Xffffff00) == 0x40  or (response[10]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[10]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[12]<<8)&~0XFFFF00FF)|(response[11]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+22, 1)
            end if
        end if
    //**************************************************************************************************************************
    // Запрос мощности Q (Реактивная)
    //**************************************************************************************************************************
        OUTPORT(PowerQ[0], "Free Protocol", 6)
        FILL(response[0], 0, 16)
        INPORT(Response[0], "Free Protocol", 15, length)
        CRC(Response[0], CRC16, 13)
        if length == 15 and Response[0]&~0Xffffff00 == netAdr then
            if (Response[13]&~0Xffffff00)==(CRC16&0xFF) and (Response[14]&~0Xffffff00)==((CRC16>>8)&0xFF) then
                // Мощность по всем фазам
                if (response[1]&~0Xffffff00) == 0x40  or (response[1]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[1]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[3]<<8)&~0XFFFF00FF)|(response[2]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+24, 1)
                // Мощность на фазе U1
                if (response[4]&~0Xffffff00) == 0x40  or (response[4]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[4]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[6]<<8)&~0XFFFF00FF)|(response[5]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+26, 1)
                // Мощность на фазе U2
                if (response[7]&~0Xffffff00) == 0x40  or (response[7]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[7]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[9]<<8)&~0XFFFF00FF)|(response[8]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+28, 1)
                // Мощность на фазе U2
                if (response[10]&~0Xffffff00) == 0x40  or (response[10]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[10]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[12]<<8)&~0XFFFF00FF)|(response[11]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+30, 1)
            end if
        end if
    //**************************************************************************************************************************
    // Запрос мощности S (Активная и Реактивная)
    //**************************************************************************************************************************
        OUTPORT(PowerS[0], "Free Protocol", 6)
        FILL(response[0], 0, 16)
        INPORT(Response[0], "Free Protocol", 15, length)
        CRC(Response[0], CRC16, 13)
        if length == 15 and Response[0]&~0Xffffff00 == netAdr then
            if (Response[13]&~0Xffffff00)==(CRC16&0xFF) and (Response[14]&~0Xffffff00)==((CRC16>>8)&0xFF) then
                // Мощность по всем фазам
                if (response[1]&~0Xffffff00) == 0x40  or (response[1]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[1]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[3]<<8)&~0XFFFF00FF)|(response[2]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+32, 1)
                // Мощность на фазе U1
                if (response[4]&~0Xffffff00) == 0x40  or (response[4]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[4]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[6]<<8)&~0XFFFF00FF)|(response[5]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+34, 1)
                // Мощность на фазе U2
                if (response[7]&~0Xffffff00) == 0x40  or (response[7]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[7]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[9]<<8)&~0XFFFF00FF)|(response[8]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+36, 1)
                // Мощность на фазе U2
                if (response[10]&~0Xffffff00) == 0x40  or (response[10]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[10]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[12]<<8)&~0XFFFF00FF)|(response[11]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+38, 1)
            end if
        end if
    //**************************************************************************************************************************
    // Запрос cos фи
    //**************************************************************************************************************************
        OUTPORT(CosF[0], "Free Protocol", 6)
        FILL(response[0], 0, 16)
        INPORT(Response[0], "Free Protocol", 15, length)
        CRC(Response[0], CRC16, 13)
        if length == 15 and Response[0]&~0Xffffff00 == netAdr then
            if (Response[13]&~0Xffffff00)==(CRC16&0xFF) and (Response[14]&~0Xffffff00)==((CRC16>>8)&0xFF) then
                // cos фи по всем фазам
                if (response[1]&~0Xffffff00) == 0x40  or (response[1]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[1]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[3]<<8)&~0XFFFF00FF)|(response[2]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+40, 1)
                // cos фи на фазе U1
                if (response[4]&~0Xffffff00) == 0x40  or (response[4]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[4]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[6]<<8)&~0XFFFF00FF)|(response[5]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+42, 1)
                // cos фи на фазе U2
                if (response[7]&~0Xffffff00) == 0x40  or (response[7]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[7]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[9]<<8)&~0XFFFF00FF)|(response[8]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+44, 1)
                // cos фи на фазе U2
                if (response[10]&~0Xffffff00) == 0x40  or (response[10]&~0Xffffff00) == 0 then
                    dir = 1
                else if (response[10]&~0Xffffff00) == 0x80 then
                    dir = -1
                end if
                temp = (((response[12]<<8)&~0XFFFF00FF)|(response[11]&~0Xffffff00)) * dir
                SetData(temp, "Local HMI", LW, adres+46, 1)
            end if
        end if
    //**************************************************************************************************************************
    // Запрос углов между фазами
    //**************************************************************************************************************************
        OUTPORT(Angle[0], "Free Protocol", 6)
        FILL(response[0], 0, 16)
        INPORT(Response[0], "Free Protocol", 12, length)
        CRC(Response[0], CRC16, 10)
        if length == 12 and Response[0]&~0Xffffff00 == netAdr then
            if (Response[10]&~0Xffffff00)==(CRC16&0xFF) and (Response[11]&~0Xffffff00)==((CRC16>>8)&0xFF) then
                temp = ((response[1]<<16)&~0XFF00FFFF)|((response[3]<<8)&~0XFFFF00FF)|(response[2]&~0Xffffff00) // угол ФАЗЫ U1
                SetData(temp, "Local HMI", LW, adres+48, 1)
                temp = ((response[4]<<16)&~0XFF00FFFF)|((response[6]<<8)&~0XFFFF00FF)|(response[5]&~0Xffffff00) // угол ФАЗЫ U2
                SetData(temp, "Local HMI", LW, adres+50, 1)
                temp = ((response[7]<<16)&~0XFF00FFFF)|((response[9]<<8)&~0XFFFF00FF)|(response[8]&~0Xffffff00) // угол ФАЗЫ U3
                SetData(temp, "Local HMI", LW, adres+52, 1)
            end if
        end if
    else
        adres + 54
        GetData(temp, "Local HMI", LW, adres+54, 1)
        if temp >= 10 then
            temp = 0
            for i = 0 to 52
                SetData(temp, "Local HMI", LW, adres+i, 1)
            next i
        else
             temp = temp + 1
        end if
        SetData(temp, "Local HMI", LW, adres+54, 1)
    end if
end sub

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функция получаем архивы накопленной энергии. Полученные данные сохраняются в память LW Weintek.
//
// -----
// netAdr - Адрес счетчика
// array  - № масив данных для получения
//          0 От сброса
//          1 За текущий год
//          2 За предыдущий год
//          3 За месяц
//          4 За текущие сутки
//          5 За предыдущие сутки
//          9 На начало текущего года
//          10 На начало предыдущего года
//          11 На начало месяца
//          12 На начало текущих суток
//          13 На начало предыдущих суток
// month  - Номер месяца
//          1 - январь
//          2 - февраль
//          3 - март
//          4 - апрель
//          5 - май
//          6 - июнь
//          7 - июль
//          8 - август
//          9 - сентябрь
//          10 - октябрь
//          11 - ноябрь
//          12 - декабрь
// tarif -  № тарифа для считывания
//          0 – энергия по сумме тарифов
//          1 – энергия по тарифу 1
//          2 – энергия по тарифу 2
//          3 – энергия по тарифу 3
//          4 – энергия по тарифу 4
// adres -- Начальная позиция памяти LW Weintek
// Карта памяти:
// Адрем           Коментарий                                       Тип данных                  Множитель
// adres           энергия активная прямая (NA+)                    (32bit unsigned int)        0.001
// adres + 2       энергия активная обратная (NA-)                  (32bit unsigned int)        0.001
// adres + 4       энергия реактивная прямая (NR+)                  (32bit unsigned int)        0.001
// adres + 6       энергия реактивная обратная (NR-)                (32bit unsigned int)        0.001
// adres + 8       Счетчик ошибок связи (при 10 обнуление)          (16bit)                     1
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
sub unsigned short getMercurysEnergy(short netAdr,short array, short month, short tarif, short adres)
    //**************************************************************************************************************************
    // Проверка входных данных
    //**************************************************************************************************************************
    if netAdr == 0 and netAdr > 256 then
        return 255
    else if (array > 5 and array < 9) and array > 13 then
        return 255
    else if month > 12 then
        return 255
    else if tarif > 4 then
        return 255
    else if adres > 9002 - 54 and adres < 11495 and adres > 12300 - 54 then
        return 255
    end if

    int temp=0
    char response[19]
    short length=0, CRC16=0
    Char Access[11]              = { 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}
    Char energy[6]               = { 0x00, 0x05 }
    Access[0]                    = netAdr
    CRC(Access[0], CRC16, 9)
    Access[9]                    = CRC16&0xFF
    Access[10]                   = (CRC16>>8)&0xFF
    energy[0]                    = netAdr
    energy[2]                    = ((array * 10) + month)|0Xffffff00
    energy[3]                    = tarif|0Xffffff00
    CRC(energy[0], CRC16, 4)
    energy[4]                    = CRC16 & 0xFF
    energy[5]                    = (CRC16>>8) & 0xFF
    //**************************************************************************************************************************
    // Получение доступа
    //**************************************************************************************************************************
    OUTPORT(Access[0], "Free Protocol", 11)
    FILL(response[0], 0, 20)
    INPORT(Response[0], "Free Protocol", 4, length)
    CRC(Response[0], CRC16, 2)
    if length == 4 and Response[0]&~0Xffffff00 == netAdr then
        if Response[1]&~0Xffffff00 == 0 and (Response[2]&~0Xffffff00)==(CRC16&0xFF) and (Response[3]&~0Xffffff00)==((CRC16>>8)&0xFF) then
            temp = 0
            SetData(temp, "Local HMI", LW, adres+54, 1)     // Сброс счетчика ошибок соеденения !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            OUTPORT(energy[0], "Free Protocol", 6)
            FILL(response[0], 0, 20)
            INPORT(Response[0], "Free Protocol", 19, length)
            CRC(Response[0], CRC16, 17)
            if length == 19 and Response[0]&~0Xffffff00 == netAdr then
                if (Response[17]&~0Xffffff00)==(CRC16&0xFF) and (Response[18]&~0Xffffff00)==((CRC16>>8)&0xFF) then
                    temp = ((response[2]<<24)&~0X00FFFFFF)|((response[1]<<16)&~0XFF00FFFF)
                    temp = temp|((response[4]<<8)&~0XFFFF00FF)|(response[3]&~0Xffffff00)
                    SetData(temp, "Local HMI", LW, adres, 1)                                    // энергия активная прямая (NA+)
                    temp = ((response[6]<<24)&~0X00FFFFFF)|((response[5]<<16)&~0XFF00FFFF)
                    temp = temp|((response[8]<<8)&~0XFFFF00FF)|(response[7]&~0Xffffff00)
                    SetData(temp, "Local HMI", LW, adres+2, 1)                                  // энергия активная обратная (NA-)
                    temp = ((response[10]<<24)&~0X00FFFFFF)|((response[9]<<16)&~0XFF00FFFF)
                    temp = temp|((response[12]<<8)&~0XFFFF00FF)|(response[11]&~0Xffffff00)
                    SetData(temp, "Local HMI", LW, adres+4, 1)                                  // энергия реактивная прямая (NR+)
                    temp = ((response[14]<<24)&~0X00FFFFFF)|((response[13]<<16)&~0XFF00FFFF)
                    temp = temp|((response[16]<<8)&~0XFFFF00FF)|(response[15]&~0Xffffff00)
                    SetData(temp, "Local HMI", LW, adres+6, 1)                                  // энергия реактивная обратная (NR-)
                end if
            end if
        end if
    end if
end sub

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функция сканирует сеть на наличие счетчиков. Полученные данные сохраняются в память LW Weintek.
//
// GetMercury(netAdr, adres)
// adres -- Начальная позиция памяти LW Weintek
//
// Карта памяти:
// Адрем            номер бита          Коментарий
// adres                                Счетчики с адресами 1-32
//                  0                   Наличие счетчика с адресом 1 (0=отсутствует 1=присутствует)
//                  1                   Наличие счетчика с адресом 2 (0=отсутствует 1=присутствует)
// adres + 2                            Счетчики с адресами 33-64
// adres + 4                            Счетчики с адресами 65-96
// adres + 6                            Счетчики с адресами 67-128
// adres + 8                            Счетчики с адресами 129-160
// adres + 10                           Счетчики с адресами 161-192
// adres + 12                           Счетчики с адресами 193-224
// adres + 14                           Счетчики с адресами 225-256
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
sub unsigned short MercurysSerch(short adres)
    //**************************************************************************************************************************
    // Проверка входных данных
    //**************************************************************************************************************************
    if adres > 9002 - 54 and adres < 11495 and adres > 12300 - 54 then
        return 255
    end if
    Char testConnect[4] = { 0x00, 0x00 }
    Char Response[16]
    unsigned int map=0, x=0
    unsigned short i=0, z=32, length=0, CRC16=0,temp=0
    Char y=1
    while i < 14
        x = 1
        while y < z
            testConnect[0] = y
            CRC(testConnect[0], CRC16, 2)
            testConnect[2] = CRC16&0xFF
            testConnect[3] = (CRC16>>8)&0xFF
            OUTPORT(testConnect[0], "Free Protocol", 4)
            FILL(response[0], 0, 16)
            INPORT(Response[0], "Free Protocol", 4, length)
            CRC(Response[0], CRC16, 2)
            if length == 4 and (Response[2]&~0Xffffff00)==(CRC16&0xFF) and (Response[3]&~0Xffffff00)==((CRC16>>8)&0xFF) then
                map = map | x
            else
                map = map &~x
            end if
            y = y + 1
            x = x << 1          												// Двоичный перебор
        wend
        SetData(map, "Local HMI", LW, adres+i, 1)
        i = i + 2
        z = z + 32
    wend
end sub

macro_command main()
    unsigned short i=0
    while i < 1
        // MercurysSerch(210)
        GetMercury(2,930)
        getMercurysEnergy(2, 0, 0, 1, 1000)
    wend
end macro_command
